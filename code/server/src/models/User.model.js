// ----------------------------------------------
// User.model.js
// This file defines the entire schema for storing the users' data of the application
// ----------------------------------------------

import mongoose from "mongoose"; // importing mongoose
import bcrypt from "bcrypt"; // importing bcrypt for hashing passwords
import jwt from "jsonwebtoken"; // importing for generating tokens

// ----------------------------------------------
// Creating the user schema and defining its fields
// ----------------------------------------------

const userSchema = new mongoose.Schema(
  {
    // The fullname of the user. The first name is mandatory and the last name is optional.
    fullName: {
      firstName: {
        type: String,
        required: true, // mandatory
        unique: false, // multiple people can have the same name
        trim: true, // removes the white space
      },
      lastName: {
        type: String,
        required: false, // optional
        unique: false,
        trim: true,
        default: "",
      },
    },

    // the unique username of the user. This could be a combination of different characters. 6 lowercase characters
    username: {
      type: String,
      required: [true, "Username is mandatory!"],
      unique: true, // unique
      lowercase: true,
      minlength: [3, "The username must be of 3 characters minimum."],
      maxlength: [30, "The username must not exceed 30 characters."],
    },

    // the profile pic of the users
    profilePic: {
      type: String,
      required: false, // users can choose not to have any profile pic
      default: "",
    },

    // the password of the user. 6-8 characters
    password: {
      type: String,
      required: true, // mandatory
      unique: false,
      minlength: [10, "You have to enter at least 10 characters"], // longer password for security
    },

    // the email of the User
    email: {
      type: String,
      required: true, // mandatory
      unique: true, // unique
      lowercase: true,
      trim: true, // removes the whitespaces
    },

    // the string for refresh tokens
    refreshTokenString: {
      type: String,
    },
  },
  {
    timestamps: true,
  }
);

// ----------------------------------------------
// Hashing the password for extra security
// ----------------------------------------------

// before saving the password, hash it
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) {
    return next(); // If password hasn't been modified, skip hashing and move on.
  }

  // 2. Perform hashing with error handling
  try {
    this.password = await bcrypt.hash(this.password, 10); // hash the passoword with 10 salt rounds
    console.log("Password successfully hashed before saving.");
    next(); // Proceed to save only after successful hashing
  } catch (error) {
    // If hashing fails, log the error and pass it to Mongoose to abort the save operation, preventing plain text data exposure.
    console.error("Failed to hash password: ", error);
    next(error); // Abort the save operation
  }
});

// ----------------------------------------------
// Method for checking if the entered password is correct
// ----------------------------------------------

// assinging a custom method to the user schema
userSchema.methods.isPasswordCorrect = async function (password) {
  if (!this.password) {
    console.warn("Attempted to compare password on a document missing a hash."); // if the stored password is missing
    return false;
  }
  try {
    // 'password' is the plain text string submitted by the user.
    // 'this.password' is the hashed string retrieved from the database document.
    const condition = await bcrypt.compare(password, this.password); // Returns a boolean
    return condition;
  } catch (error) {
    // If the comparison fails due to a library error (e.g., malformed hash)
    console.error("Critical error during password comparison:", error.message);
    return false;
  }
};

// ----------------------------------------------
// Token generators (Custom Methods)
// ----------------------------------------------

// the access token
userSchema.methods.generateAccessToken = function () {
  return jwt.sign(
    {
      // saving the information of the user
      _id: this._id, // the automatic id generated by MongoDB
      username: this.username,
    },
    process.env.ACCESS_TOKEN_SECRET, // the secret key to generate the token
    {
      expiresIn: process.env.ACCESS_TOKEN_EXPIRY,
    }
  );
};

// the refresh token
userSchema.methods.generateRefreshToken = function (uniqueTokenString) {
  return jwt.sign(
    {
      id: this._id, // the id is saved for the refresh token
      uniqueToken: uniqueTokenString, // this unique string separates two distinct refresh tokens
    },
    process.env.REFRESH_TOKEN_SECRET,
    {
      expiresIn: process.env.REFRESH_TOKEN_EXPIRY,
    }
  );
};

// ----------------------------------------------
// Creating the User model based on "userSchema"
// ----------------------------------------------

const User = new mongoose.model("User", userSchema);

export default User; // exporting the model as default
